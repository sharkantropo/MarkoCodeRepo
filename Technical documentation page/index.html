<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Python 3.7 Doc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" media="screen" href="scss/output.css" />
</head>

<body>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  <!-- User Story #1: I can see a main element with a corresponding id="main-doc", which contains the page's main content (technical documentation).
User Story #2: Within the #main-doc element, I can see several section elements, each with a class of main-section. There should be a minimum of 5.
User Story #3: The first element within each .main-section should be a header element which contains text that describes the topic of that section.
User Story #4: Each section element with the class of main-section should also have an id that corresponds with the text of each header contained within it. Any spaces should be replaced with underscores (e.g. The section that contains the header "Javascript and Java" should have a corresponding id="Javascript_and_Java").
User Story #5: The .main-section elements should contain at least 10 p elements total (not each).
User Story #6: The .main-section elements should contain at least 5 code elements total (not each).
User Story #7: The .main-section elements should contain at least 5 li items total (not each).
User Story #8: I can see a nav element with a corresponding id="navbar".
User Story #9: The navbar element should contain one header element which contains text that describes the topic of the technical documentation.
User Story #10: Additionally, the navbar should contain link (a) elements with the class of nav-link. There should be one for every element with the class main-section.
User Story #11: The header element in the navbar must come before any link (a) elements in the navbar.
User Story #12: Each element with the class of nav-link should contain text that corresponds to the header text within each section (e.g. if you have a "Hello world" section/header, your navbar should have an element which contains the text "Hello world").
User Story #13: When I click on a navbar element, the page should navigate to the corresponding section of the main-doc element (e.g. If I click on a nav-link element that contains the text "Hello world", the page navigates to a section element that has that id and contains the corresponding header.
User Story #14: On regular sized devices (laptops, desktops), the element with id="navbar" should be shown on the left side of the screen and should always be visible to the user.
User Story #15: My Technical Documentation page should use at least one media query.
*/-->
  <nav id="navbar">
    <header id="topic">Python 3.7.0 Tutorial</header>
    <ul>
      <a class="nav-link" href="#Introduction" rel="internal"><li>Introduction</li></a>
      <a class="nav-link" href="#Whetting_your_Appetite" rel="internal"><li>Whetting your Appetite</li></a>
      <a class="nav-link" href="#Using_the_Python_Interpreter" rel="internal"><li>Using the Python Interpreter</li></a>
      <a class="nav-link" href="#Using_Python_as_a_Calculator" rel="internal"><li>Using Python as a Calculator</li></a>
      <a class="nav-link" href="#More_Control_Flow_Tools" rel="internal"><li>More Control Flow Tools</li></a>
      <a class="nav-link" href="#Find_out_more"><li>Find out more</li></a>
    </ul>
  </nav>
  <main id="main-doc">
    <section class="main-section" id="Introduction">
      <header>Introduction</header>
      <p>Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple
        but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with
        its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on
        most platforms. The Python interpreter and the extensive standard library are freely available in source or binary
        form for all major platforms from the Python Web site, <a href="https://www.python.org/">Python.org</a> , and may
        be freely distributed. The same site also contains distributions of and pointers to many free third party Python
        modules, programs and tools, and additional documentation.
      </p>

      <p>The Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages
        callable from C). Python is also suitable as an extension language for customizable applications. This tutorial introduces
        the reader informally to the basic concepts and features of the Python language and system. It helps to have a Python
        interpreter handy for hands-on experience, but all examples are self-contained, so the tutorial can be read off-line
        as well.</p>
    </section>
    <section class="main-section" id="Whetting_your_Appetite">
      <header>Whetting your Appetite</header>
      <p>If you do much work on computers, eventually you find that there’s some task you’d like to automate. For example,
        you may wish to perform a search-and-replace over a large number of text files, or rename and rearrange a bunch of
        photo files in a complicated way. Perhaps you’d like to write a small custom database, or a specialized GUI application,
        or a simple game. If you’re a professional software developer, you may have to work with several C/C++/Java libraries
        but find the usual write/compile/test/re-compile cycle is too slow. Perhaps you’re writing a test suite for such
        a library and find writing the testing code a tedious task. Or maybe you’ve written a program that could use an extension
        language, and you don’t want to design and implement a whole new language for your application.</p>
      <p>Python is just the language for you.</p>
      <p>You could write a Unix shell script or Windows batch files for some of these tasks, but shell scripts are best at
        moving around files and changing text data, not well-suited for GUI applications or games. You could write a C/C++/Java
        program, but it can take a lot of development time to get even a first-draft program. Python is simpler to use, available
        on Windows, Mac OS X, and Unix operating systems, and will help you get the job done more quickly. Python is simple
        to use, but it is a real programming language, offering much more structure and support for large programs than shell
        scripts or batch files can offer. On the other hand, Python also offers much more error checking than C, and, being
        a very-high-level language, it has high-level data types built in, such as flexible arrays and dictionaries. Because
        of its more general data types Python is applicable to a much larger problem domain than Awk or even Perl, yet many
        things are at least as easy in Python as in those languages.</p>
      <p>Python allows you to split your program into modules that can be reused in other Python programs. It comes with
        a large collection of standard modules that you can use as the basis of your programs — or as examples to start learning
        to program in Python. Some of these modules provide things like file I/O, system calls, sockets, and even interfaces
        to graphical user interface toolkits like Tk. Python is an interpreted language, which can save you considerable
        time during program development because no compilation and linking is necessary. The interpreter can be used interactively,
        which makes it easy to experiment with features of the language, to write throw-away programs, or to test functions
        during bottom-up program development. It is also a handy desk calculator.</p>
      <p>Python enables programs to be written compactly and readably. Programs written in Python are typically much shorter
        than equivalent C, C++, or Java programs, for several reasons:</p>
      <ul>
        <li>The high-level data types allow you to express complex operations in a single statement.</li>
        <li>Statement grouping is done by indentation instead of beginning and ending brackets.</li>
        <li>No variable or argument declarations are necessary.</li>
      </ul>
      <p>Python is extensible: if you know how to program in C it is easy to add a new built-in function or module to the
        interpreter, either to perform critical operations at maximum speed, or to link Python programs to libraries that
        may only be available in binary form (such as a vendor-specific graphics library). Once you are really hooked, you
        can link the Python interpreter into an application written in C and use it as an extension or command language for
        that application.</p>
      <p>By the way, the language is named after the BBC show “Monty Python’s Flying Circus” and has nothing to do with reptiles.
        Making references to Monty Python skits in documentation is not only allowed, it is encouraged!</p>
    </section>
    <section class="main-section" id="Using_the_Python_Interpreter">
      <header>Using the Python Interpreter</header>
      <h2 id="Invoking_the_Interpreter">Invoking the Interpreter</h2>
      <p>The Python interpreter is usually installed as /usr/local/bin/python3.7 on those machines where it is available;
        putting /usr/local/bin in your Unix shell’s search path makes it possible to start it by typing the command:</p>
      <code>python3.7</code>
      <p>to the shell.. Since the choice of the directory where the interpreter lives is an installation option, other places
        are possible; check with your local Python guru or system administrator. (E.g., /usr/local/python is a popular alternative
        location.)
      </p>
      <p>On Windows machines, the Python installation is usually placed in C:\Python36, though you can change this when you’re
        running the installer. To add this directory to your path, you can type the following command into the command prompt
        in a DOS box:</p>
      <code>set path=%path%;<br>C:\python36</code>
      <p>Typing an end-of-file character (Control-D on Unix, Control-Z on Windows) at the primary prompt causes the interpreter
        to exit with a zero exit status. If that doesn’t work, you can exit the interpreter by typing the following command:
        quit().
      </p>
      <p>The interpreter’s line-editing features include interactive editing, history substitution and code completion on
        systems that support readline. Perhaps the quickest check to see whether command line editing is supported is typing
        Control-P to the first Python prompt you get.</p>
      <p>The interpreter operates somewhat like the Unix shell: when called with standard input connected to a tty device,
        it reads and executes commands interactively; when called with a file name argument or with a file as standard input,
        it reads and executes a script from that file. A second way of starting the interpreter is python -c command [arg]
        ..., which executes the statement(s) in command, analogous to the shell’s -c option. Since Python statements often
        contain spaces or other characters that are special to the shell, it is usually advised to quote command in its entirety
        with single quotes. Some Python modules are also useful as scripts. These can be invoked using python -m module [arg]
        ..., which executes the source file for module as if you had spelled out its full name on the command line. When
        a script file is used, it is sometimes useful to be able to run the script and enter interactive mode afterwards.
        This can be done by passing -i before the script.</p>
      <h3 id="argument">Argument Passing</h3>
      <p>When known to the interpreter, the script name and additional arguments thereafter are turned into a list of strings
        and assigned to the argv variable in the sys module. You can access this list by executing import sys. The length
        of the list is at least one; when no script and no arguments are given, sys.argv[0] is an empty string. When the
        script name is given as '-' (meaning standard input), sys.argv[0] is set to '-'. When -c command is used, sys.argv[0]
        is set to '-c'. When -m module is used, sys.argv[0] is set to the full name of the located module. Options found
        after -c command or -m module are not consumed by the Python interpreter’s option processing but left in sys.argv
        for the command or module to handle.</p>
      <h3 id="interactive">Interactive mode</h3>
      <p>When commands are read from a tty, the interpreter is said to be in interactive mode. In this mode it prompts for
        the next command with the primary prompt, usually three greater-than signs (>>>); for continuation lines it prompts
        with the secondary prompt, by default three dots (...). The interpreter prints a welcome message stating its version
        number and a copyright notice before printing the first prompt:</p>
      <code>$ python3.7 <br>
          Python 3.7 (default, Sep 16 2015, 09:25:04) <br>
          [GCC 4.8.2] on linux <br>
          Type "help", "copyright", "credits" or "license" for more information. <br>
          >>></code>
      <p>Continuation lines are needed when entering a multi-line construct. As an example, take a look at this if statement:</p>
      <code>>>> the_world_is_flat = True <br>
        >>> if the_world_is_flat: <br>
        ...     print("Be careful not to fall off!") <br>
        ... <br>
        Be careful not to fall off!</code>
      <h2 id="interpreter_environment">The Interpreter and its environment</h2>
      <p>By default, Python source files are treated as encoded in UTF-8. In that encoding, characters of most languages
        in the world can be used simultaneously in string literals, identifiers and comments — although the standard library
        only uses ASCII characters for identifiers, a convention that any portable code should follow. To display all these
        characters properly, your editor must recognize that the file is UTF-8, and it must use a font that supports all
        the characters in the file. To declare an encoding other than the default one, a special comment line should be added
        as the first line of the file. The syntax is as follows:
      </p>
      <code># -*- coding: encoding -*-</code>
      <p>where encoding is one of the valid codecs supported by Python. For example, to declare that Windows-1252 encoding
        is to be used, the first line of your source code file should be:</p>
      <code># -*- coding: cp1252 -*-</code>
      <p>One exception to the first line rule is when the source code starts with a <a href="https://docs.python.org/3/tutorial/appendix.html#tut-scripts">UNIX
          “shebang” line</a>. In this case, the encoding declaration should be added as the second line of the file. For
        example:
      </p>
    </section>
    <section class="main-section" id="Using_Python_as_a_Calculator">
      <header>Using Python as a Calculator</header>
      <p>Let’s try some simple Python commands. Start the interpreter and wait for the primary prompt, >>>. (It shouldn’t
        take long.)</p>
      <h2 id="numbers">Numbers</h2>
      <p>The interpreter acts as a simple calculator: you can type an expression at it and it will write the value. Expression
        syntax is straightforward: the operators +, -, * and / work just like in most other languages (for example, Pascal
        or C); parentheses (()) can be used for grouping. For example:</p>
      <code>>>> 2 + 2 <br>
4 <br>
>>> 50 - 5*6   <br>
20  <br>
>>> (50 - 5*6) / 4  <br>
5.0 <br>
>>> 8 / 5  # division always returns a floating point number
1.6</code>
      <p>The integer numbers (e.g. 2, 4, 20) have type int, the ones with a fractional part (e.g. 5.0, 1.6) have type float.
        We will see more about numeric types later in the tutorial. Division (/) always returns a float. To do floor division
        and get an integer result (discarding any fractional result) you can use the // operator; to calculate the remainder
        you can use %:</p>
      <code>>>> 17 / 3  # classic division returns a float <br>
          5.666666666666667 <br>
          >>> <br>
          >>> 17 // 3  # floor division discards the fractional part   <br>
          5 <br>
          >>> 17 % 3  # the % operator returns the remainder of the division <br>
          2 <br>
          >>> 5 * 3 + 2  # result * divisor + remainder <br>
          17</code>
      <p>With Python, it is possible to use the ** operator to calculate powers:</p>
      <code>>>> 5 ** 2  # 5 squared <br>
25 <br>
>>> 2 ** 7  # 2 to the power of 7 <br>
128</code>
      <p>The equal sign (=) is used to assign a value to a variable. Afterwards, no result is displayed before the next interactive
        prompt:
      </p>
      <code>>>> width = 20 <br>
>>> height = 5 * 9  <br>
>>> width * height  <br>
900</code>
      <p>If a variable is not “defined” (assigned a value), trying to use it will give you an error:</p>
      <code>>>> n  # try to access an undefined variable <br>
Traceback (most recent call last): <br>
  File "<stdin>", line 1, in <module> <br>
NameError: name 'n' is not defined</code>
      <p>There is full support for floating point; operators with mixed type operands convert the integer operand to floating
        point:
      </p>
      <code>>>> 4 * 3.75 - 1
14.0</code>
      <p>In interactive mode, the last printed expression is assigned to the variable _. This means that when you are using
        Python as a desk calculator, it is somewhat easier to continue calculations, for example:</p>
      <code>>>> tax = 12.5 / 100 <br>
>>> price = 100.50 <br>
>>> price * tax <br>
12.5625 <br>
>>> price + _ <br>
113.0625  <br>
>>> round(_, 2) <br>
113.06</code>
      <p>This variable should be treated as read-only by the user. Don’t explicitly assign a value to it — you would create
        an independent local variable with the same name masking the built-in variable with its magic behavior. In addition
        to int and float, Python supports other types of numbers, such as Decimal and Fraction. Python also has built-in
        support for complex numbers, and uses the j or J suffix to indicate the imaginary part (e.g. 3+5j).</p>
      <h2 id="strings">Strings</h2>
      <p>Besides numbers, Python can also manipulate strings, which can be expressed in several ways. They can be enclosed
        in single quotes ('...') or double quotes ("...") with the same result [2]. \ can be used to escape quotes:</p>
      <code>>>> 'spam eggs'  # single quotes <br>
'spam eggs' <br>
>>> 'doesn\'t'  # use \' to escape the single quote... <br>
"doesn't" <br>
>>> "doesn't"  # ...or use double quotes instead <br>
"doesn't" <br>
>>> '"Yes," they said.' <br>
'"Yes," they said.' <br>
>>> "\"Yes,\" they said." <br>
'"Yes," they said.' <br>
>>> '"Isn\'t," they said.' <br>
'"Isn\'t," they said.'</code>
      <p>In the interactive interpreter, the output string is enclosed in quotes and special characters are escaped with
        backslashes. While this might sometimes look different from the input (the enclosing quotes could change), the two
        strings are equivalent. The string is enclosed in double quotes if the string contains a single quote and no double
        quotes, otherwise it is enclosed in single quotes. The print() function produces a more readable output, by omitting
        the enclosing quotes and by printing escaped and special characters:</p>
      <code>>>> '"Isn\'t," they said.' <br>
'"Isn\'t," they said.' <br>
>>> print('"Isn\'t," they said.') <br>
"Isn't," they said. <br>
>>> s = 'First line.\nSecond line.'  # \n means newline <br>
>>> s  # without print(), \n is included in the output  <br>
'First line.\nSecond line.' <br>
>>> print(s)  # with print(), \n produces a new line  <br>
First line. <br>
Second line.</code>
      <p>If you don’t want characters prefaced by \ to be interpreted as special characters, you can use raw strings by adding
        an r before the first quote:</p>
      <code>>>> print('C:\some\name')  # here \n means newline! <br>
C:\some <br>
ame <br>
>>> print(r'C:\some\name')  # note the r before the quote <br>
C:\some\name</code>
      <p>String literals can span multiple lines. One way is using triple-quotes: """...""" or '''...'''. End of lines are
        automatically included in the string, but it’s possible to prevent this by adding a \ at the end of the line. The
        following example:</p>
      <code>print("""\ <br>
Usage: thingy [OPTIONS] <br>
     -h                        Display this usage message <br>
     -H hostname               Hostname to connect to <br>
""")</code>
      <p>produces the following output (note that the initial newline is not included):</p>
      <code>Usage: thingy [OPTIONS] <br>
     -h                        Display this usage message <br>
     -H hostname               Hostname to connect to</code>
      <p>Strings can be concatenated (glued together) with the + operator, and repeated with *:</p>
      <code>>>> # 3 times 'un', followed by 'ium' <br>
>>> 3 * 'un' + 'ium' <br>
'unununium'</code>
      <p>Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated.</p>
      <code>>>> 'Py' 'thon' <br>
'Python'</code>
      <p>This feature is particularly useful when you want to break long strings:</p>
      <code>>>> text = ('Put several strings within parentheses ' <br>
...         'to have them joined together.') <br>
>>> text <br>
'Put several strings within parentheses to have them joined together.'</code>
      <p>This only works with two literals though, not with variables or expressions:</p>
      <code>>>> prefix = 'Py' <br>
>>> prefix 'thon'  # can't concatenate a variable and a string literal <br>
  ... <br>
SyntaxError: invalid syntax <br>
>>> ('un' * 3) 'ium' <br>
  ... <br>
SyntaxError: invalid syntax</code>
      <p>If you want to concatenate variables or a variable and a literal, use +:</p>
      <code>>>> prefix + 'thon' <br>
'Python'</code>
      <p>Strings can be indexed (subscripted), with the first character having index 0. There is no separate character type;
        a character is simply a string of size one:</p>
      <code>>>> word = 'Python' <br>
>>> word[0]  # character in position 0  <br>
'P' <br>
>>> word[5]  # character in position 5  <br>
'n'</code>
      <p>Indices may also be negative numbers, to start counting from the right:</p>
      <code>>>> word[-1]  # last character <br>
'n' <br>
>>> word[-2]  # second-last character <br>
'o' <br>
>>> word[-6] <br>
'P'</code>
      <p>Note that since -0 is the same as 0, negative indices start from -1. In addition to indexing, slicing is also supported.
        While indexing is used to obtain individual characters, slicing allows you to obtain substring:</p>
      <code>>>> word[0:2]  # characters from position 0 (included) to 2 (excluded) <br>
'Py' <br>
>>> word[2:5]  # characters from position 2 (included) to 5 (excluded) <br>
'tho'</code>
      <p>Note how the start is always included, and the end always excluded. This makes sure that s[:i] + s[i:] is always
        equal to s:</p>
      <code>>>> word[:2] + word[2:] <br>
'Python' <br>
>>> word[:4] + word[4:] <br>
'Python'</code>
      <p>Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to
        the size of the string being sliced.</p>
      <code>>>> word[:2]   # character from the beginning to position 2 (excluded) <br>
'Py' <br>
>>> word[4:]   # characters from position 4 (included) to the end <br>
'on' <br>
>>> word[-2:]  # characters from the second-last (included) to the end <br>
'on'</code>
      <p>One way to remember how slices work is to think of the indices as pointing between characters, with the left edge
        of the first character numbered 0. Then the right edge of the last character of a string of n characters has index
        n, for example:</p>
      <code> +---+---+---+---+---+---+ <br>
 | P | y | t | h | o | n | <br>
 +---+---+---+---+---+---+ <br>
 0   1   2   3   4   5   6 <br>
-6  -5  -4  -3  -2  -1</code>
      <p>The first row of numbers gives the position of the indices 0…6 in the string; the second row gives the corresponding
        negative indices. The slice from i to j consists of all characters between the edges labeled i and j, respectively.
        For non-negative indices, the length of a slice is the difference of the indices, if both are within bounds. For
        example, the length of word[1:3] is 2. Attempting to use an index that is too large will result in an error:</p>
      <code>>>> word[42]  # the word only has 6 characters <br>
Traceback (most recent call last): <br>
  File "<stdin>", line 1, in <module> <br>
IndexError: string index out of range</code>
      <p>However, out of range slice indexes are handled gracefully when used for slicing:</p>
      <code>>>> word[4:42] <br>
'on' <br>
>>> word[42:] <br>
''</code>
      <p>Python strings cannot be changed — they are immutable. Therefore, assigning to an indexed position in the string
        results in an error:</p>
      <code>>>> word[0] = 'J' <br>
  ... <br>
TypeError: 'str' object does not support item assignment <br>
>>> word[2:] = 'py' <br>
  ... <br>
TypeError: 'str' object does not support item assignment</code>
      <p>If you need a different string, you should create a new one:</p>
      <code>>>> 'J' + word[1:] <br>
'Jython' <br>
>>> word[:2] + 'py' <br>
'Pypy'</code>
      <p>The built-in function <a href="https://docs.python.org/3/library/functions.html#len">len()</a> returns the length
        of a string:</p>
      <code>>>> s = 'supercalifragilisticexpialidocious' <br>
>>> len(s) <br>
34</code>
      <h2 id="lists">Lists</h2>
      <p>Python knows a number of compound data types, used to group together other values. The most versatile is the list,
        which can be written as a list of comma-separated values (items) between square brackets. Lists might contain items
        of different types, but usually the items all have the same type.</p>
      <code>>>> squares = [1, 4, 9, 16, 25] <br>
>>> squares <br>
[1, 4, 9, 16, 25]</code>
      <p>Like strings (and all other built-in sequence type), lists can be indexed and sliced:</p>
      <code>>>> squares[0]  # indexing returns the item <br>
1 <br>
>>> squares[-1] <br>
25 <br>
>>> squares[-3:]  # slicing returns a new list <br>
[9, 16, 25]</code>
      <p>All slice operations return a new list containing the requested elements. This means that the following slice returns
        a new (shallow) copy of the list:</p>
      <code>>>> squares[:] <br>
[1, 4, 9, 16, 25]</code>
      <p>Lists also support operations like concatenation:</p>
      <code>>>> squares + [36, 49, 64, 81, 100] <br>
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code>
      <p>Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content:</p>
      <code>>>> cubes = [1, 8, 27, 65, 125]  # something's wrong here <br>
>>> 4 ** 3  # the cube of 4 is 64, not 65! <br>
64 <br>
>>> cubes[3] = 64  # replace the wrong value <br>
>>> cubes <br>
[1, 8, 27, 64, 125]</code>
      <p>You can also add new items at the end of the list, by using the append() method (we will see more about methods
        later):
      </p>
      <code>>>> cubes.append(216)  # add the cube of 6 <br>
>>> cubes.append(7 ** 3)  # and the cube of 7 <br>
>>> cubes <br>
[1, 8, 27, 64, 125, 216, 343]</code>
      <p>Assignment to slices is also possible, and this can even change the size of the list or clear it entirely:</p>
      <code>>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] <br>
>>> letters <br>
['a', 'b', 'c', 'd', 'e', 'f', 'g'] <br>
>>> # replace some values <br>
>>> letters[2:5] = ['C', 'D', 'E'] <br>
>>> letters <br>
['a', 'b', 'C', 'D', 'E', 'f', 'g'] <br>
>>> # now remove them <br>
>>> letters[2:5] = [] <br>
>>> letters <br>
['a', 'b', 'f', 'g'] <br>
>>> # clear the list by replacing all the elements with an empty list <br>
>>> letters[:] = [] <br>
>>> letters <br>
[]</code>
      <p>The built-in function <a href="https://docs.python.org/3/library/functions.html#len">len()</a> also applies to lists:
      </p>
      <code>>>> letters = ['a', 'b', 'c', 'd'] <br>
>>> len(letters) <br>
4</code>
      <p>It is possible to nest lists (create lists containing other lists), for example:</p>
      <code>>>> a = ['a', 'b', 'c'] <br>
>>> n = [1, 2, 3] <br>
>>> x = [a, n] <br>
>>> x <br>
[['a', 'b', 'c'], [1, 2, 3]] <br>
>>> x[0] <br>
['a', 'b', 'c'] <br>
>>> x[0][1] <br>
'b'</code>
      <h2 id="first_steps">First Steps Towards Programming</h2>
      <p>Of course, we can use Python for more complicated tasks than adding two and two together. For instance, we can write
        an initial sub-sequence of the Fibonacci series as follows:</p>
      <code>>>> # Fibonacci series: <br>
... # the sum of two elements defines the next <br>
... a, b = 0, 1 <br>
>>> while a < 10: <br>
...     print(a) <br>
...     a, b = b, a+b <br>
... <br>
0 <br>
1 <br>
1 <br>
2 <br>
3 <br>
5 <br>
8</code>
      <p>This example introduces several new features.</p>
      <ul>
        <li>The first line contains a multiple assignment: the variables a and b simultaneously get the new values 0 and
          1. On the last line this is used again, demonstrating that the expressions on the right-hand side are all evaluated
          first before any of the assignments take place. The right-hand side expressions are evaluated from the left to
          the right.</li>
        <li>The <a href="https://docs.python.org/3/reference/compound_stmts.html#while">while</a> loop executes as long as
          the condition (here: a
          < 10) remains true. In Python, like in C, any non-zero integer value is true; zero is false. The condition may also be a
            string or list value, in fact any sequence; anything with a non-zero length is true, empty sequences are false.
            The test used in the example is a simple comparison. The standard comparison operators are written the same as
            in C: < (less than),> (greater than), == (equal to),
            <=( less than or equal to),>= (greater than or equal to) and != (not equal to).
        </li>
        <li>The body of the loop is indented: indentation is Python’s way of grouping statements. At the interactive prompt,
          you have to type a tab or space(s) for each indented line. In practice you will prepare more complicated input
          for Python with a text editor; all decent text editors have an auto-indent facility. When a compound statement
          is entered interactively, it must be followed by a blank line to indicate completion (since the parser cannot guess
          when you have typed the last line). Note that each line within a basic block must be indented by the same amount.</li>
        <li>The <a href="https://docs.python.org/3/library/functions.html#print">print()</a> function writes the value of
          the argument(s) it is given. It differs from just writing the expression you want to write (as we did earlier in
          the calculator examples) in the way it handles multiple arguments, floating point quantities, and strings. Strings
          are printed without quotes, and a space is inserted between items, so you can format things nicely, like this:
          <code>>>> i = 256*256 <br>
>>> print('The value of i is', i) <br>
The value of i is 65536</code> The keyword argument end can be used to avoid the newline after the output, or end
          the output with a different string:
          <code>>>> a, b = 0, 1 <br>
>>> while a < 1000: <br>
...     print(a, end=',') <br>
...     a, b = b, a+b <br>
... <br>
0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</code>
        </li>
      </ul>
    </section>
    <section class="main-section" id="More_Control_Flow_Tools">
      <header>More Control Flow Tools</header>
      <p>Besides the <a href="https://docs.python.org/3/reference/compound_stmts.html#while">while</a> while statement just
        introduced, Python knows the usual control flow statements known from other languages, with some twists.</p>
      <h2 id="if_statement">The If Statement</h2>
      <p>Perhaps the most well-known statement type is the if statement. For example:</p>
      <code>>>> x = int(input("Please enter an integer: ")) <br>
Please enter an integer: 42 <br>
>>> if x < 0: <br>
...     x = 0 <br>
...     print('Negative changed to zero') <br>
... elif x == 0: <br>
...     print('Zero') <br>
... elif x == 1: <br>
...     print('Single') <br>
... else: <br>
...     print('More') <br>
... <br>
More</code>
      <p>There can be zero or more elif parts, and the else part is optional. The keyword ‘elif’ is short for ‘else if’,
        and is useful to avoid excessive indentation. An if … elif … elif … sequence is a substitute for the switch or case
        statements found in other languages.</p>
      <h2 id="for_statement">The for Statement</h2>
      <p>The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating
        over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration
        step and halting condition (as C), Python’s for statement iterates over the items of any sequence (a list or a string),
        in the order that they appear in the sequence. For example (no pun intended):</p>
      <code>>>> # Measure some strings: <br>
... words = ['cat', 'window', 'defenestrate'] <br>
>>> for w in words: <br>
...     print(w, len(w)) <br>
... <br>
cat 3 <br>
window 6 <br>
defenestrate 12</code>
      <p>If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected
        items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy.
        The slice notation makes this especially convenient:</p>
      <code>>>> for w in words[:]:  # Loop over a slice copy of the entire list. <br>
...     if len(w) > 6: <br>
...         words.insert(0, w) <br>
... <br>
>>> words <br>
['defenestrate', 'cat', 'window', 'defenestrate']</code>
      <p>With for w in words:, the example would attempt to create an infinite list, inserting defenestrate over and over
        again.
      </p>
      <h2 id="range_function">The range() function</h2>
      <p>If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates
        arithmetic progressions:</p>
      <code>>>> for i in range(5): <br>
...     print(i) <br>
... <br>
0 <br>
1 <br>
2 <br>
3 <br>
4</code>
      <p>The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for
        items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different
        increment (even negative; sometimes this is called the ‘step’):</p>
      <code>range(5, 10) <br>
   5, 6, 7, 8, 9 <br>

range(0, 10, 3) <br>
   0, 3, 6, 9 <br>

range(-10, -100, -30) <br>
  -10, -40, -70</code>
      <p>To iterate over the indices of a sequence, you can combine range() and len() as follows:</p>
      <code>>>> a = ['Mary', 'had', 'a', 'little', 'lamb'] <br>
>>> for i in range(len(a)): <br>
...     print(i, a[i]) <br>
... <br>
0 Mary <br>
1 had <br>
2 a <br>
3 little <br>
4 lamb</code>
      <p>In most such cases, however, it is convenient to use the <a href="https://docs.python.org/3/library/functions.html#enumerate">enumerate()</a>
        function.</p>
      <p>A strange thing happens if you just print a range:</p>
      <code>>>> print(range(10)) <br>
range(0, 10)</code>
      <p>In many ways the object returned by range() behaves as if it is a list, but in fact it isn’t. It is an object which
        returns the successive items of the desired sequence when you iterate over it, but it doesn’t really make the list,
        thus saving space. We say such an object is iterable, that is, suitable as a target for functions and constructs
        that expect something from which they can obtain successive items until the supply is exhausted. We have seen that
        the for statement is such an iterator. The function list() is another; it creates lists from iterables:</p>
      <code>>>> list(range(5)) <br>
[0, 1, 2, 3, 4]</code>
    </section>
    <br>
    <section class="main-section" id="Find_out_more">
      <header>Find out more</header>
      <p>For further information, visit <a href="https://docs.python.org/3/contents.html"> Official Python Documentation
          page.</a></p>
    </section>
  </main>
</body>

</html>